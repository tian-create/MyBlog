---
title: JavaScript - 理解执行上下文
tags: 执行上下文
categories: javascript
---
#### **理解执行上下文**

​	执行上下文：函数执行前进行的准备工作（也称执行上下文环境）

​	运行javascript代码时，当代码执行进入一个环境时，就会为该环境创建一个执行上下文，它会在你运行代码前做一些准备工作，如确定作用域，创建局部变量对象等。


<!--more-->
#### **javascript中执行环境**

 1. 全局执行上下文 - 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。

 2. 函数执行上下文 - 当执行一个函数时，运行函数体中的代码。

    javascript运行时首先会进入全局环境，对应会生成全局上下文。程序代码基本会存在函数，那么调用函数，就会进入函数执行环境，对应就会生成该函数的执行上下文。

    > 记住：js是单线程的！！！也就是同一时间段只能做一件事，完成之后才能做下一个。剩余的要在后面排队。



#### **多个执行上下文怎么管理**

​		函数编码中，会声明多个函数，对应的执行上下文也会存在多个。

​		**在javascript中，我们通过栈来存取管理执行上下文，称为执行栈，或者函数调用栈。**

##### 		**插播**：栈数据结构

​				栈遵循“**先进后出，后进先出**”的规则，也就是最先入栈的会放在栈底，最后入栈的放在最上面；可以用我们今天的例子来讲解：

```jsx
var a=10,d=20;
function fn(x){
    var a=100,c=300;
    
    function bar(x){
        var a=1000,d=4000;
    }
    
    bar(100); // arguments: x: 100
    bar(200); // arguments: x: 200
}
fn(10);

/*创建执行上下文，并推入到当前栈顶并执行，执行完毕出栈*/
/*
	首先进入全局执行上下文，把全局推入到栈顶并执行，
	执行遇到fn函数被调用，进入fn函数的执行上下文，推入到栈顶并执行，
	执行遇到bar(100)函数被调用，进入bar(100)函数的执行上下文，推入栈顶并执行，执行完毕出栈
	遇到bar(200)函数被调用，进入bar(200)函数的执行上下文，推入栈顶并执行，执行完毕出栈
	出栈回到fn()函数的执行上下文，继续执行fn()函数执行上下文，执行完毕出栈，回到全局执行上下文
*/
/*
	入栈顺序：
		4.bar(200)    
		3.bar(100)   
		2.fn()
		1.全局执行上下文（最先）   
	
	出栈顺序：
		4.全局执行上下文（最后）  
		3.fn()
		2.bar(100) 
		1.bar(200)    
*/
```

栈数据的特点：

1. 后进先出，先进后出
2. 出口在顶部，且只有一个



##### **执行栈（函数调用栈）**

​		程序执行进入一个执行环境时，它的执行上下文就会被创建，并被推入执行栈中（入栈）；程序执行完成时，它的执行上下文就会被销毁，并从栈顶部被推出（出栈），控制权交给下一个执行上下文。

​		

​		因为js执行中最先进入的是全局环境，所以处于**栈底的永远是全局环境的执行上下文**。而处于**栈顶的是当前正在执行函数的执行上下文**，当函数调用完成后，它就会被栈顶推出。

​	

​		**“全局环境只有一个，对应的全局环境的执行上下文也只有一个，只有当页面被关闭之后，他才会从执行栈中被推出，否则一直存在于栈底。”**



#### 执行上下文的生命周期

​	执行上下文的生命周期有两个阶段：

  1. 创建阶段（进入执行上下文）

  2. 执行阶段（代码执行）

     

     创建阶段：函数被调用时，进入函数环境，为其创建一个执行上下文，此时进入创建阶段。

     执行阶段：执行函数中的代码，此时执行上下文进入执行阶段



##### 创建阶段的操作

1. 创建变量对象
   - 函数环境会初始化创建arguments对象（并赋值）
   - 函数声明（并赋值）
   - 变量声明，函数表达式声明（未赋值）

2. 确定this指向（this由调用者确定）
3. 确定作用域（哪里声明定义，就在哪里确定）



##### 执行阶段的操作

 	1. 变量对象赋值
     - 变量赋值
     - 函数表达式赋值
 	2. 调用函数
 	3. 顺序执行其他代码



##### 变量对象和活动对象的区别

​	当进入一个执行上下文后，这个变量对象才会被激发，所以叫活动对象（AO），这个时候活动对象上的各种属性才能够被访问。

​	“**创建阶段对函数声明做赋值，变量和函数表达式仅做声明，真正的赋值操作要等到执行上下文代码的执行阶段。**”



变量提升：

```jsx
function foo(){
    console.log(a); //undefined
    var a = '你好呀~';
}
foo();

// 实际的执行过程
function foo(){
    var a; //变量声明，var初始化undefined
    console.log(a);
    a = '你好呀~'; //重新赋值
}
foo();
```



函数声明优先级：

```jsx
function foo(){
    console.log(bar);
    var bar = 20;
    function bar(){
        return 10;
    }
    var bar = function(){
        return 30;
    }
}
foo(); //输出bar()整个函数声明
```



##### 总结

1. javascript是单线程
2. 栈顶的执行上下文处于执行中，其他需要排队
3. 全局上下文只有一个处于栈底，页面关闭时出栈
4. 函数执行上下文可存在多个
5. 函数调用时就会创建新的上下文，即使调用自身，也会创建不同的执行上下文



##### 练习

```jsx
//1.
var foo =1;
function bar(){
    console.log(foo);  //  ?
    if(!foo){
        var foo =10;
    }
    console.log(foo);   //  ? 
}
bar();

//2.
var a =1;
function b(){
    console.log(a);   // ? 
    a =10;
    return;
    function a(){}
}
b();
console.log(a);     //  ? 

//3.
var f =true;
if(f===true){
    var a =10;
}
function fn(){
    var b =20;
    c=30;
}
fn();
console.log(a); //  ? 
console.log(c); // ? 
console.log(b); //  ? 

//4.
var a =b=3;
 (function(){
    var a =b=5;         //  ? 
 })()
 console.log(a);        // ? 
 console.log(b);  //  ? 

//5.
console.log('第1个',foo);   //   ? 
var foo ='A';
console.log('第2个',foo); //  ? 
var foo =function(){
    console.log('B');
}
console.log('第3个', foo);  //  ? 
foo(); // ?
function foo(){
    console.log('C');
}
console.log('第4个', foo); // ? 
foo(); // ?

//6.
var a =1;
 function b(){
     console.log(a); // ? 
     a =2;
     console.log(a);//  ? 
     var a=3;
     console.log(a);//  ? 
 }
 console.log(a);// ? 
 b();
 console.log(a);// ? 

//7.
var a = 10;
var obj = {
    a: 1,
    b: 2,
    c: [{
        a: 3,
        b: 4,
        eat: function(){
            console.log(this.a);
        }
    }]
}
obj.c[0].eat(); // ? 

//8.
var o = {
    a: 10,
    b: {
        a: 12,
        fn: function(){
            console.log(this.a); // ? 
            console.log(this); // ? 
        }
    }
}

o.b.fn(); 

//9.
var o = {
    a: 10,
    b:  {
        fn: function(){
            console.log(this.a); // ?  
            console.log(this);   // ? 
        }
    }
}

o.b.fn();
```

