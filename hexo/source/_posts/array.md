---
title: JavaScript - 数组
tags: 数组
categories: js
---
## 数组
> 什么是数组？通过字面的意义直面理解数组就是把数据组合在一起

JavaScript里面的数定义:

**数组是存放一系列数据的集合**
<!--more-->
---
#### 数组的定义
##### 第一种方式Array
这一种方式，我们可以直接使用JS的内置对象Array来进行

在使用这一种方式的时候，它非常简单，如下所示就可以了

```js
var nums = new Array();
// 这样我们就创建了一个数组nums

在上面的代码里面，我们看到了一个关键字 new
我们在控制台打印出nums的时候，我们会看到有一个 [] ，这是数组表示形式上的特点
```
通过上面的方式创建的数组，我们会发现它是一个空的数组，它是一个空的数组里面没有任何元素，所以，我们可以把这个数组的长度理解为0

**小技巧：** 一个数组如果要得到它的长度，我们可以使用一个属性**数组.length**

```js
var nums = new Array();
nums.length; // 这个时候会得到数字0，因为数组的长度为0，而length则代表这个数组的长度
```
在我们定义数组的时候，我们还可以直接就定义数组的长度

```js
var nums = new Array(5);
// 我们会得到一个长度为5的数组
nums.length; // 得到结果为5
```
**注意：**
创建数组如果要确定长度，那么你放进去的只可能是正整数，不能是小数，也不能是负数，并且只能有一个数字

```js
var a=new Array(3.14); // 错误的定义方式，会提示“非法的数组长度”
var b=new Array(-3); // 错误的定义方式，会提示“非法的数组长度”
```

当我们在定义数组的时候，如果已经确定了数组里面的内容 ，我们可以直接的把数组内容放进去

```js
var f=new Array("香蕉","苹果","哈密瓜","草莓","梨");
// 现在我们定义数组的时候，我就直接把里面放了5个水果
```
当我们去通过Array定义数组的时候，最常见的三种情况就是上面的三种情况：
1. 第一种直接定义一个空数组，这个空数组的长度为0，
2. 第二种定义了一个有长度的数组，但这个数组里面每个值都是空的，
3. 第三个则在定义数组的时候，就把需要放到数组里面的元素直接丢进去了
```js
var a=new Array();
var b=new Array(5);
var c=new Array("香蕉","苹果","哈密瓜","草莓","梨");
```
**细节注意：**
我们要确定一点，new Array("值")放一个值的时候，它首先会通过一次typeof 值的检测，如果这个值是number类型，再去判断这个值是否是正整数，如果是，则表示数组定义的长度，否则就是数组的值

```js
var a=new Array("5");   //代表定义数组，直接把"5"放进去
/*
	typeof "5"  得到"string"  不是number类型 ，所以它代表数组里面的值
*/
var b=new Array(5);     //代表定义一个长度为5的数组
/*
	typeof 5 得到"number"类型 ，然后判断是否大于或等于0，第三步是否是整数
*/
```

---

##### 第二种方式 []
当我们通过第一种方式定义好数组以后，我们在控制打输出这个数组，我们会发现数组使用的是中括号 [] 来表示,通过这点我们在以后定义数组的时候可以直接使用中括号来定义

```js
var nums=new Array();
var nums2=[];

/* 这一种方式就相当于定义了一个空的数组，上面的两行代码最终得到的结果是一样的 */
```
我们也可以像第一种一样，直接去定义数组里面的值

```js
var a=new Array("香蕉","苹果","哈密瓜","草莓","梨");
var b=["香蕉","苹果","哈密瓜","草莓","梨"];

可以理解为：new Array() = [];
```
**小细节注意：**

在我们使用Array去定义数组的时候，我们可以直接定义数组的长度

```js
var a=new Array(5);
//这代表定义了一个数组，它的长度为5
a.length;   //得到的结果是5
```
但是我们在通过[]去定义数组的时候，不能够直接定义数组的长度

```js
var b=[5];
//这不代表数组的长度。而代表数组里面有一个值，这个值是5
b.length;   //得到结果1  里面有个元素是5
```
==**解决方案：**==

```js
我们都知道数组的长度是使用length来表示的，现在我们就通过它来解决

//第一种定义的情况
var a=new Array(5);

//如果转化成第二种定义情况
var b=[];   //定义了一个长度为0的数组
b.length=5;   //重新设定数组的长度为5
```

---
#### JS数组与其他变成语言的异同
##### 数组的取值与赋值相同
1. JS数组的取值与赋值跟其它的编程言是一样的，它们都是通过下标取值与赋值（下标也叫索引，可以把它理解书本上面的页码，通过索引，可以快速的定位到数组里面的值）
2. JS数组与其它编程语言数组一样，它的索引（下标）是从0开始的，它们的取值与赋值都是 **数组[索引值]**
```js
var a=['苹果', '香蕉', '梨'];
a[0]; //苹果
a[1]; //香蕉
a[2]; //梨
a[2] = '哈密瓜'; //把值赋值到数组的第三个位置
console.log(a); //得到['苹果', '香蕉', '哈密瓜'];
```
##### 数据类型的区别
在其它的编程语言里面，数组里面的值使用的是同一个数组类型，**而在JS的数组里面，里面的值的数据类型可以不相同**
```js
var arr=["张三",18,true,null,undefined,"",NaN];
//现在上面的数组里面，放了多个值，这些值包含了我们JS里面的5种基本数据类型
```
把上面的代码在控制台运行以后，没有报错，并且我们展开数组以后发现所有的值都存进去了，所以我们可以得出结论：**JS数组里面值的数据类型 ，我们可以不相同**

##### 数组长度与最大索引的区别
在其它的编程语言里面，数组的长度决定了最大索引，例如如果在C/C++/Java等编程语言（强类型语言）里面，如果数组的长度为6，那么它最大的索引应该是5（长度决定最大索引）

**在JavaScript里面的数组，最大索引决定了数组当前的长度**

> 通过上面的相同点与不同点的结论，我们可以得出一个，JS数组不限定长度，也不限制数据类型!(正是因为这个特点，所以JS把数组也当成了集合)

---
#### 数组类型的检测
我们可以通过typeof关键字来检测数据类型，typeof 只能检测了基本的数据类型与对象类型 ，而不能够具体的检测出数组

如果判断这个变量是否是数组，我们还需要做一次检测

##### 使用 instanceof 关键字
instanceof 主要的作用与 typeof 相似，typeof 主要用于检测基本数据类型，而instanceof主要用于检测对象类型

```js
var num=new Array();
num instanceof Array; // 判断num是否是Array new出来的
```
>如果， **变量 instanceof Array** 得到的值为true，则代表它是一个数组，否则就不是一个数组

##### Array.isArray() 检测
除了通过之前的instanceof关键字以外，我们还可以使用自带的方法去检测

```js
var num=new Array();
Array.isArray(num); // 判断num是否为数组
```
> 如果上面的结果为true，则说明num是数组，如果得到false，则说明num不是数组

当我们检测出一个变量为数组以后，我们就可以让这个数组来解决我们工作当中遇到的问题，例如将元素添加到数组，删除数组里面的值，遍历数组等方式

---

#### 数组的取值与赋值
当我们创建一个数组以后，这个数组里面可以存放任意多个值，这些数组里面的值，我们叫“元素”

```js
var stu=["张三","李四","王五"];
// 在上面的stu数组里面，我们可以把"张三，李四，王五"这三个值叫元素
```
当一个数组好了以后，我们可以通过下标（索引）来进行赋值与赋值

```js
stu[0];   //取出了第一个元素的值  "张三"
stu[1]="丁六";   //对数组的第一个元素进行赋值
```

```js
//如果我现在想在刚刚的数组后面添加一个元素（”哈哈“）
var stu=["张三","李四","王五"];
var length=stu.length;  //取到数组的长度 length = 3
stu[length]="哈哈"; // stu[3] 就是第四个值
```
++如果向前面添加元素，就会很麻烦 ，所以，我们除了使用数组的下标来取值或赋值以外，我们还需要使用一些特殊的技术来对数组的元素进行添加或删除等相关操作++

> 数组提供了一系列的方法来进行操作，这些方法是提供给用户的使用的，可以提高我们操作数组的简便程度

---

#### 数组的常用方法与属性
> 方法：用于使用（调用）

> 属性：用于描述一些事物的特征（特性）

1. length 属性：用于获取或设置数组的长度
```js
var num=new Array(5);
num.length;
```

2. push() 方法：直接向当前的数组后面去追加新的元素
```js
var stu=["张三","李四","王五"];
stu.push('赵六'); // 把赵六添加到当前数组的最后面去

stu.push('哈哈', '嘻嘻'); // 可以同时添加多个元素
```

3. pop() 方法：移除当前数组的最后一个元素，并且可以得到这个元素
```js
var stu=["张三","李四","王五"];
var a = stu.pop();
console.log(a); // 王五
//上面的代码执行了两个过程
//第一个过程是移除了stu数组的最后一个元素“王五”
//第二个过程，把移出来的这个元素”李昊“赋值给了变量a
```

4. unshift() 方法：在数组的最前面去添加元素
```js
var stu=["张三","李四","王五"];
stu.unshift('老李');//在数组的最前面添加元素"老李"

//unshift与push一样，都可以一次性添加多个元素
stu.unshift("小李","小王");
```

5. shift() 方法：在数组的前面移除一个元素，并且可以得到这个元素
```js
var stu=["张三","李四","王五"];
var a=stu.shift(); 
console.log(a); //张三
//上面的代码也执行了两个过程 
//第一个过程是把最前面的“张三”移出来
//第二个过程则是把移出来的“张三”赋值给了变量a
```

6. reverse()方法：该方法会将当前数组里面的元素进行反转
```js
var stu=["张三","李四","王五"];
stu.reverse();
// 这个时候，里面的数组会进行反转
```

7. concat() 方法：将多个数组里面的元素进行合并，然后得到一个心得数组
```js
var arr1=["a","b","c"];
var arr2=[1,2,3];
var arr3=[true,false,null];
var _a=arr1.concat(arr2);   //它将arr1与arr2进行相连，得到一个新的数组_a，不影响原来的数组
var _b = arr1.concat(arr2,arr3); 
//它也可以同时连接多个数组
```

8. toString() 方法：该方法讲数组转换成字符串，里面的原则用“逗号” **,** 来隔开
```js
var arr=["a","b","c"];
arr.toString();   //"a,b,c";   
var arr1=[1,2,3,4,5];
arr1.toString();  //"1,2,3,4,5"
```

9. join() 方法：将元素转换成字符串，然后按指定的符号隔开，如果未指定符号，则默认使用逗号 , 隔开
```js
var arr=["a","b","c"];
arr.join("#");   //"a#b#c";
var arr1=[1,2,3,4,5];
arr.join();   //"1,2,3,4,5";  不添加符号，则默认使用逗号来进行
```

10. splice() 方法：替换数组里面的元素
```js
var arr=[100,200,300,400,500];
arr.splice(1,2,'aaa','bbb');
// [100, 'aaa', 'bbb', 400, 500]
/*
	第一个1代表开始替换的索引
	第二个2代表替换元素的个数
	后面的"aaa","bbbb"代表替换以后新的元素
*/
arr.splice(1,3,'aaa','bbb','ccc');
// [100, 'aaa', 'bbb', 'ccc', 500];
```
扩展第一种情况
```js
var arr=[100,200,300,400,500];
arr.splice(1,2);

/*
    在上面的代码里面，我们可以看从，第一个参数代表开始索引，第二个参数代表要替换的元素个数
    这个时候，如果我们只是替换元素出来而不向里面添加元素，这个时候这个过程就相当于删除过程
*/
```
扩展第二种情况
```js
var arr=[100,200,300,400,500];
arr.splice(2); //[100,200]
// 从索引2开始，后面的全部删掉
```
扩展第三种情况
```js
向数组的特定位置添加元素

var arr=["张三","李四","曾七","王八"];
//现在请将"王五"，"赵六"插入到”李四“与”曾七“的中间
arr.splice(2,0,"王五","赵六");
/*
    索引2的位置，没有替换元素，而是添加了两个元素
    原来索引2的“曾七”变成了添加的“王五”
*/
```

11. indexOf() 方法：查询数组当中某个元素的索引的位置，默认从0的索引开始查询，一直查询到最后一个，如果找到多个，则返回第一个的位置
```js
var arr=["张三","李四","李四","曾七"];
arr.indexOf('张三'); // 0

如果找到这个元素就得到这个元素所在的索引值，如果没有找到则得到一个“-1”
```

12. slice() 方法：提取现有数组里面的元素，得到一个新的数组，它不会影响到原来的数组
```js
arr.slice(start,end)
第一个参数代表起始索引
第二个参数代表结束索引的前一个

var arr=["a","b","c","d","e","f"];
var arr2 = arr.slice(1,4);
// 起始索引1 元素为"b"，结束索引4 元素为"e"，"e"的前一个为"d"
// arr2的结束就是 ["b","c","d"]  
```
```js
如果start是负数，那么规定从数组尾部开始算起。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。
如果end是负数，那么规定的是从数组尾部开始算起的参数。

var arr=["a","b","c","d","e","f"];
arr.slice(-1); // f
arr.slice(-4); // c d e f
arr.slice(-4,1); // [] 得不到结果，在我开始之前了
arr.slice(-4,3); // ['c']
arr.slice(-4,-2); // ?
```

##### 数组练习

```js
给你一个数组[1,8,6,2,7,9,9,4,8,2,6]，请把这个数组变成手机号：18627994826

var telArr = ['1','8','6','2','7','9','9','4','8','2','6'];
var tel = Number(telArr.join(''));
console.log('我的手机号', tel);
```

---
#### 循环得到数组里面的每一个元素

```js
var arr=[1,4,7,9,2,8,3,6,11,54,23];
```
> 首先经过学习我们已经知道数组元素的取值与赋值都是通过索引来进行，如果我们需要把数组里面的每个元素都取到，那么我们就要把里面的每个索引都拿一次

> 我们也都知道索引是从0开始，到length-1结束，所以我们要在这个范围里面不停的去拿，这个地方我们做了一件重复的事情，就需要for循环了

##### for 循环
经过分析，我们知道循环的起始条件就应该是数组的初始索引值为0，结束条件就是数组的最大索引length-1

```js
//循环生成，i是从0开始 到length-1  指的是数组的每一个索引值
for(var i=0;i<=arr.length-1;i++){
    console.log(arr[i]);
}

// i<=arr.length-1可以换成i<arr.length
```
##### for...in

```js
var arr = [1,2,3,4,5];
for(var i in arr){
    console.log(i);// 0-4 
    // i 代表数组里面的每一项索引
    console.log(arr[i]); // 1-5
}

上面的for...in 也是一种数组的遍历方式
```

---

#### 数组的迭代方法
数组可以使用第三方的方式来遍历里面的元素（for或for...in）,同时也可以使用数组自带的方法来进行遍历

1. forEach 方法
```js
arr.forEach(function(item,index,arr){
    // item代表当前元素
    // index代表当前索引 
    // arr代表当前正在遍历的数组
    console.log(item,index);
});

1.数组的forEach回调函数中写入执行代码段就可以
2.这里回调函数有三个参数，第一个 表示数组的每一个值，第二个表示下标，第三个表示当前数组
3.注意forEach 不能使用break与continue等方法终止遍历
```

2. map 方法
```js
map 会为数组的每一个值去执行代码块，对返回的结果组成一个数组，作为整个遍历返回的值

var arr = [0,1,2,3,4];
var newArr = arr.map(function(item, index, arr){
   return item/2; 
});
console.log(newArr); // [0, 0.5, 1, 1.5, 2]
```

3. filter 过滤方法
```js
filter对数组中的每一项运行给定函数，返回该函数符合要求的项组成的数组

var arr = [1,3,3,4,5];
var arr2 = arr.filter(function(item, index, arr){
    // 通过找到当前的index索引和item索引相同，就说明是同一个元素，如果不相同就是重复的元素
    // index: 0 1 2 3 4
    // arr.indexOf(item): 0 1 1 3 4 
    //因为通过indexOf方法查询到了两个相同的元素3，这个时候返回第一个的位置 1
    // filter直接过滤掉了我们重复索引的元素3，因此得到了一个去重的数组
    if(index == arr.indexOf(item)){
        return item;
    }
})
console.log(arr2); // [1,3,4,5]
```

4. some 方法
```js
这个遍布方法也有一个返回值，它的返回是布尔类型

some方法类似于 || 的逻辑语句判断，会为数组每一个值执行判断语句，只要有一个满足条件，整个遍历的返回值就为true

var arr3 = [2,3,4,5];
var arr4 = arr3.some(function(item, index){
    return (item > 2)
})
console.log('arr4', arr4); // true
```

5. every 方法
```js
该方法与上面的some方法相对，相当于执行了且的运算

every的遍历会对数组的每一个值执行回调函数中的语句，只有在每一个值都为true时，整个遍历返回值为true，否则为false

var arr3 = [2,3,4,5];
var arr4 = arr3.some(function(item, index){
    return (item > 2)
})
console.log('arr4', arr4); // false
```

---

#### 归并方法 reduce()
归并方法
归并方法也是迭代方法的一种，但也不完全的迭代方法，它的回调方法里面有四个参数

```js
arr.reduce(function(prev,cur,index,arr){
...
}, init);

arr：表示原数组；

prev：表示上一次调用回调时的返回值，或者初始值 init;

cur：表示当前正在处理的数组元素；

index：表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；

init：表示初始值。

常用参数：prev 和 cur
```
实例：
先提供一个数组

```js
var arr = [3,9,4,3,6,0,9];
```
##### 求数组项之和

```js
var sum = arr.reduce(function(){
    return prev + cur;
}, 0);
console.log('sum', sum); // 34
```
由于传入了初始值0，所以开始时prev的值为0，cur的值为数组的第一项，相加之后返回值为3，作为下一轮回调的prev值，然后再继续与下一个数组项相加，以此类推，直至完成所有数组项的和并返回。

---

#### 排序方法 sort()
sort() 方法能够根据一定条件对数组元素进行排序。

如果调用 sort() 方法时没有传递参数，则按字母顺序对数组中的元素进行排序。

```js
var sortA = ['a','c','b','d'];
sortA.sort();
console.log(sortA); // ['a','b','c','d']
```
使用 sort() 方法时，应该注意下面几个问题。
1. 所谓的字母顺序，实际上是根据字母在字符编码表中的顺序进行排列的，每个字符在字符表中都有一个唯一的编号。
2. 如果元素不是字符串，则 sort() 方法试图把数组元素都转换成字符串，以便进行比较。
3. sort() 方法将根据元素值进行逐位比较，而不是根据字符串的个数进行排序。
```js
var a = ["aba","baa","aab"];  定义数组
a.sort();  //按字母顺序对元素进行排序
console.log(a);  //返回数组[aab,aba,baa]

/* 在排序时，首先比较每个元素的第 1 个字符，在第 1 个字符相同的情况下，再比较第 2 个字符，以此类推。 */
```

4. 在任何情况下，数组中 undefined 的元素都被排序在末尾。
5. sort() 方法是在原数组基础上进行排序操作的，不会创建新的数组。
sort() 方法不仅按字母顺序进行排序，还可以根据其他顺序执行操作。
如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：
    - 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；
    - 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。
    - 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。
    - compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。
比较函数格式如下：
```js
function compare(a, b) {
  if (a < b ) {           
    // 按某种排序标准进行比较, a 小于 b
    return -1;
  }
  if (a > b ) {
    return 1;
  }
  return 0;
}
```
要比较数字而非字符串，比较函数可以简单的以a-b，如下的函数将会将数组升序排列（由小大大）
```js
function compareNumbers(a, b) {
  return a - b;
}

// a - b < 0  顺序a b 说明a小 = 2 - 4 顺序 2 4
// a - b > 0  顺序b a 说明b小 = 4 - 2 顺序 2 4
// a - b 就是小的值在前，用来做升序排列
```
sort 方法可以使用函数表达式方便书写为：
```js
var numbers = [4, 2, 5, 1, 3];
numbers.sort(function(a, b) {
  return a - b;
});
console.log(numbers); // [1, 2, 3, 4, 5]
```
降序处理（由大到小）
```js
function compareNumbers(a, b) {
  return b - a;
}

// b - a < 0 顺序 a b 说明a大 = 2 - 4 顺序 4 2
// b - a > 0 顺序 b a 说明b大 = 4 - 2 顺序 4 2
// b - a 就是大的值在前，用来做降序排列
```
```js
冒泡排序：
var ltArr = [3, 4, 8, 1];
var temp;
for(var i=0; i<ltArr.length; i++){
    for(var j=i; j<ltArr.length; j++){
        if(ltArr[i] > ltArr[j]){
            temp = ltArr[i];
            ltArr[i] = ltArr[j];
            ltArr[j] = temp;
        }
        /* if(ltArr[i] < ltArr[j]){
            temp = ltArr[i];
            ltArr[i] = ltArr[j];
            ltArr[j] = temp;
        } */
    }
}
console.log('ltArr', ltArr);
```

---

## 二维数组
> js在严格的意义上面来说是没有二维数组的概念，它只有多维数组概念


```js
var name0="张三";
var name1="李四";
var name2="王五";
var name3="赵六";
//现在我们有四人变量，这样写义很麻烦 ，所以我们可以通过数组的形式来定义，集中管理
var names=["张三","李四","王五","赵六"];

通过数组，我们可以将上面的变量数据做集中式管理

//----------------------------

var age0=18;
var age1=19;
var age2=29;
var age3=25;
//现在又有了四个变量，我们这样定也很麻烦 ，这个时候，又可能通过数组
var ages=[18,19,29,25]

当我们如果还需要将学生的性别，籍贯等信息也保存下来，做集中式管理的时候，又需要再次定义两个数组，
但是我们都知道，这些数据在这里都是用于形容学生信息的，当变量名过多的时候，我们就不好管理

//----------------------------

var stus=[names,ages]; 

现在我们将学生的姓名和年纪做了一次数组的组合，这个时候我们就可以通过数组名stus去管理这个班级的数据了

//上面的代码等同于
var stus = [["张三","李四","王五","赵六"],[18,19,29,25];
```

---

#### 二维数组的定义
1. 通过 **Array** 的方法来定义
```js
var stus = new Array();
stus[0] = new Array();
stus[1] = new Array();

// 上面的方式我们采用的是一步一步去定义的方式 ，先定义一维的普通的数组，然后里面的值又是一个数组

//----------------------------
var stus = new Array([],[]); 
//-----------------------------
var stus = new Array(new Array(), new Array());
//-----------------------------
var stus = new Array(new Array(4), new Array(4));
//-----------------------------
var stus = new Array(new Array("张三","李四","王五","赵六"),new Array(18,19,29,25));
```

2. 通过 **[ ]** 来定义
```js
var stus = [[1,2,3,4],["a","b"],[true,false]];
```

---

#### 二维数组的取值和赋值
在数组里面，我们的取值方式是通过数组名[索引]来取值

```js
// 如果我想取到里面的“李四”，以及 29 应该怎么取？
var stus=[["张三","李四","王五","赵六"],[18,19,29,25]];
var names = stus[0]; // 取到了stus里面的第一个值，也就是第一个数组
var name1 = names[1]; // 再通过数组取值的方式去取它里面的“李四”

//----------------------------
二维数组的取值我们划分成了两部分

var name1 = stus[0][1]; // “李四”
var age1 = stus[1][2]; // 29
```
我们可以把取值与赋值看成一个表（先行后列）

JS为什么会存在二维数组的概念是因为JS如果在内部要实现表的数据结构是通过二维数组来进行的，但是JS又不是一个完整意义上的表

```js
var stus=[["张三","李四","王五","赵六"],[18,19,29]];

在上面的数组里面，我们可以看到姓名在这里是四个元素，而年龄则是三个，
在其它的编程语言这是不允许的，但是在JS里面，因为JS没有限定数组的长度，所以这是正常的
```

```js
var stus = [["张三","李四","王五","赵六"],[18,19,29],true,"hello world"];
// 这种也是可以的
```
**JS没有严格意义上面的二维数组，它有只有多维**

```js
var infos = [["张三", "李四", "王五", "赵六", ["小李","老李"]], [18, 19, 29]];
// 现在如果要取“小李”
var names = info[0][4][0];

// infos长度结果
infos.length; // 2
```
**思考？**
现有如下数组，请遍历出数组当中的所有元素

```js
var infos = [["张金","张民龙","邓俊峰","方振锋",["杨欢","杜金雪"]],[18,19,29],true,
"hello",["陈昭文","兰砣",["胡定超","甘才志"]]];
```

```js
infos.forEach(function(item, index){
    if(Array.isArray(item)){
        item.forEach(function(item, index){
            console.log(item)
            if(Array.isArray(item)){
                item.forEach(function(item, index){
                    console.log(item);
                });
            } else{
                console.log(item);
            } 
        })
    } else{
        console.log(item);
    }
});
```


